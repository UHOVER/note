# 排序

```c++
// 数组 arr 的长度
int length = (sizeof(arr)) / (sizeof(a[0]))

// 申请和释放内存
// malloc,free是c语言中用法
// new,delete是c++中用法
```

### 冒泡排序

> 它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；<br />
> 如果前者比后者大，则交换它们的位置。这样，一次遍历后，最大的元素就在数列的末尾。 <br />
> 采用相同的方法再次遍历时，第二大的元素被排列在最大元素之前。重复此操作，直到整个数列都有序为止。

```c++
void bubble_sort(int a[], int n)
{
    int i, j;
    for (i=n-1; i>0; i--)
    {
        // 将 a[0...i]中最大的数据放在末尾
        for (j=0; j<i; j++)
        {
            if (a[j] > a[j+1])
                swap(a[j], a[j+1]);
        }
    }
}
```

### 快速排序

> (1) 从数列中挑出一个基准值。<br />
> (2) 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出后，该基准就处于数列的中间位置。<br />
> (3) 递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序

```c++
/**
参数说明:
    a : 待排序的数组
    l : 数组的左边界(从起始位置开始排序，则1=0)
    r : 数组的右边界(排序截至到数组末尾，则r=a.length-1)

取左边界x=a[i]，然后跟右边界a[j]比较，小于它则j--，一直到大于为止，然后将该值方法左边界i的位置；
然后取i++值和目前的j比较，a[i] < x 则 i++,直到 a[i] > x，将a[i]的值放在a[j]；
依次类推，知道i>=j,则将 a[i] = x
*/
void quick_sort(int a[], int l, int r)
{
    if (l < r)
    {
        int i,j,x;
        i = l;
        j = r;
        x = a[i];
        while (i < j)
        {
            while (i < j && a[j] > x)
                j--; // 从右向左找第一个小于x的数
            if (i < j)
                a[i++] = a[j];
            while (i < j && a[i] < x)
                i++; // 从左向右找第一个大于x的数
            if (i < j)
                a[j--] = a[i];
        }
        a[i] = x;
        quick_sort(a, l, i-1); /* 递归调用 */
        quick_sort(a, i+1, r); /* 递归调用 */
    }
}
```

### 插入排序

> 把n个待排序的元素看成一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。

```c++
/**
参数说明:
    a: 待排序的数组
    n: 数组的长度
*/
void insert_sort(int a[], int n)
{
    int temp;
    for (int i=1; i<n; ++i)// 从数组的第二个元素开始
    {
        temp = arr[i];
        int j = i -1;
        while (j >= 0 && temp < arr[j]) // 将当前元素与之前排好序的元素进行挨个比较
        {
            arr[j+1] = arr[j]; // 已排好序的序列整体向后移
            --j;
        }
        arr[j+1] = temp;
    }
}
```

### 选择排序

> 首先在未排序的数列中找到最小的元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小的元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```c++
/**
参数说明:
    a: 待排序的数组
    n: 数组长度
*/
void select_sort(int a[], int n)
{
    int i; //有序区的尾部位置
    int j; //无序区的起始位置
    int min; //无序区最小元素位置
    for (i=0; i<n; i++)
    {
        min = i;
        // 找出 a[i+1] ... a[n-1]之间的最小元素，并赋值给min
        for (j=i+1; j<n; j++)
        {
            if (a[j] < a[min])
                min = j;
        }
        // 若min!=i,则交换 a[i]和a[min]
        // 交换后，保证了a[0]...a[i]之间的元素是有序的
        if (min != i)
            swap(a[i], a[min]);
    }
}
```

### 堆排序

> 最大堆：父结点的键值总是大于或等于任何一个子节点的键值；<br />
> 最小堆：父结点的键值总是小于或等于任何一个子节点的键值。

> 最大堆升序排序:<br />
> (1) 初始化堆:将数列a[1...n]构造成最大堆<br />
> (2) 交换数据: 将a[1]和a[n]交换，使a[n]是a[1...n] 中的最大值；然后将a[1...n-1]重新调整为最大堆。接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；依次类推，直到整个数列都是有序的。

> 性质:<br />
> 第一个元素的索引i=0:<br />
> 性质1: 索引为i的左孩子的索引是(2*i+1);<br />
> 性质2: 索引为i的右孩子的索引是(2*i+2); <br />
> 性质3: 索引为i的父节点的索引是 floor((i-1)/2)

```c++
/**
(最大)堆的向下调整算法

注: 数组实现的堆中，第N个节点的左孩子的索引值是(2N+1),右孩子的索引是(2N+2)。
    其中，N为数组下标索引值，如数组中第1个数对应的N为0

参数说明:
    a    : 待排序的数组
    start: 被下调节点的起始位置(一般为0，表示从第1个开始)
    end  : 截至范围(一般为数组中最后一个元素的索引)
*/
void maxheap_down(int a[], int start, int end)
{
    int c = start;  // 当前节点的位置
    int l = 2*c +1; // 左(left)孩子的位置
    int tmp = a[c]; // 当前节点的值
    for (; l <= end; c=l,l=2*l+1)
    {
        // l 是左孩子，l+1是右孩子
        if(l < end && a[l] < a[l+1])
            l++; // 左右两孩子中选择较大者，及 m_heap[l+1]
        if(tmp >= a[l])
            break; //调整结束
        else
        {
            a[c] = a[l];
            a[l] = tmp;
        }
    }
}

/**
堆排序(从小到大)

参数说明:
    a: 待排序的数组
    n: 数组的长度
*/
void heap_sort_asc(int a[], int n)
{
    int i;
    // 从(n/2-1)->0 逐次遍历。遍历之后，得到的数组实际上是一个(最大)二叉堆
    for (i=n/2-1; i>=0; i--) // n/2-1 最后一个拥有子节点的节点
        maxheap_down(a, i, n-1);

    // 从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素
    for (i=n-1; i>0; i--)
    {
        // 交换 a[0]和 a[i]
        swap(a[0], a[i]);
        // 调整 a[0...i-1],使得 a[0...i-1]仍然是一个最大堆
        maxheap_down(a,0,i-1);
    }
}

```




































END