物理传输介质

### 物理层
定义电气特性
Hosts->Hub
Hub
	功能：将终端的PC连接在一起
	工作原理: 收到数据后，发到所有连接改Hub的PC
	所有数据的冲突域、广播域、共享带宽
	Hub所有的端口都在同一个冲突域、广播域、共享带宽
CSMA/CD 传输数据(解决共享带宽问题)
	传送封装包(PC端过来的数据包或者返回的排队的数据包)-> 是否有空闲 -> I-否 -> 返回排队
    -> I-是 -> 空档持续 96bit-time -> II-否  -> 返回排队
    -> II-是  -> 送出封装包 -> 是否发送碰撞 -> III-否 -> 发送完毕
    -> III-是 -> 通知大家 -> 碰撞16次 -> IIII-否  -> 返回排队
    -> IIII-是 -> 放弃传送，通知上层

同类设备用交叉线，异类设备用直通线
DCE(数据通讯设备): 交换机、网桥、集线器、不带路由的modem
DTE(数据终端设备): PC、SERVER、路由器、带路由的modem
### 数据链路层
Hosts->Hub->交换机

交换机三大功能：地址学习、转发过滤、消除回路

交换机的工作原理(交换机接收数据如何处理)
当交换机接收到数据后,首先地址学习:将收到的帧的源MAC地址与进入端口编号相关联，放入 CAM 表中，然后取出目的 MAC 地址，查看是否是交换机本身的，如果是，自己留下处理，否则，将再次查看 CAM 表，如果 CAM 表中有对应的条目，将数据按照条目指定的端口转发出去，否则，将泛洪[所有连接交换机的端口转发出去]。
泛洪后续: PC接收到泛洪数据后，先解析帧数据，发现目标MAC地址不是自己的，将丢弃；是自己的，然后接收解析后，回复，交换机接收到回复，将MAC地址与端口编号关联，放入 CAM 表。不泛洪的话，没有回复这一步

转发与过滤：当交换机接收到数据发现源和目标 MAC 地址都在一个目标端口时，直接丢弃。[是因为在同一目标端口的数据在 Hub 已经泛洪]
消除回路: 

CAM 表：初始是空的，并且300秒刷新

####################################################################

数据封装和解封装
			net A					  						net B
			用户数据											用户数据
		 	|												^
		 	V 												|
应用层		应用头|用户数据 									应用头|用户数据
		 	|												^
		 	V 												|
传输层		TCP头|应用数据									TCP头|应用数据
		 	|												^
		 	V 												|
互联网层		IP头|TCP头|应用数据								IP头|TCP头|应用数据
		 	|												^
		 	V 												|
数据链路层 	以太帧头|IP头|TCP头|应用数据|以太帧尾				以太帧头|IP头|TCP头|应用数据|以太帧尾  
		 	|												^
		 	V 												|
物理层		0101010101				---[路由、网线等]-->		0101010101	

分用(也称解封):根据报文的首部，来选择数据要发送给对应的上层的某一个协议


### 应用层
File Transfer(文件传输): TFTP、FTP、NFS
E-Mail: SMTP
Remote Login(远程登录):Telnet、rlogin
Network Management(网络): SNMP
Name Management(名称管理协议):DNS

### 传输层 
[TCP/UDP]

1B(byte,字节) = 8 b(bit,比特)

## TCP报文格式
位置 名称(英文名) 					  长度/比特(bit)
1：	源端口(Source port)		 	  16			
2： 目标端口(Destination port)      16			
3:  顺序号(Sequence number)		  32
4:  确认号(Acknowledgement number) 32
5： 头长度(Header length) 		  4
6： 保留位(Reserved) 				  6
7： 代码位(Code bits)				  6
8： 窗口(Window) 				  16
9： 校验和(Checksum) 				  16
10：紧急指针(Urgent) 				  16		
11：选项(Options) 			0 or 32 if any
12：数据(Data) 					varies
__________________________________________________________________
源端口随机生成，在1024--49151 之间
(源端口和目标端口)端口数: 2^16 = 65536
0--1023 : 		公认端口号 (80[www],21[ftp],23[telnet]...)
1024--49151:    注册端口号(个人公司服务)
49152--65536：   私有端口号(研究)

顺序号、确认号：实现数据的确认重传
窗口：发送方和目的方协商一次发送多少数据(控制流量)
校验和：检验报文是否有损坏
数据：上层传送来的数据	
1--10：从上面到这里固定长度20 Bytes

6个代码位：
URG:紧急指针有效
ACK:确认序号有效
PSH:接收方应尽快将这个报文段交给应用层
RST:连接重置
SYN:同步序号用来发起一个连接
FIN:表示要终止一个连接

选项：
最长报文大小MSS(默认值536) + 20(IP) + 20(TCP) = 576(路由MTU)
__________________________________________________________________

# TCP 可靠传输机制--三次握手建立连接 
	Host A					  			Host B
1   Send SYN					-->   	SYN received
	(seq=100,ctl=SYN)  
	[ctl 发送的是同步信息]
	[seq 顺序号，随机产生,100]
2	SYN received				<--	  	Send SYN,ACK
							  			(Seq=300 ack=101 ctl=syn,ack)
							  			[ctl 发送同步确认信息，要求同步]
							  			[seq 顺序号，随机产生,300]
							  			[ack 确认号，是 A的 seq+1,101]
3	Established					-->		B收到后三次握手确认成功
	(seq=101 ack=301 ctl=ack)  
	[ctl 发送确认信息，确认同步]
	[seq 顺序号，B的ack,101]
	[ack 确认号，是 B的 seq+1,301]

# TCP 可靠传输机制--确认重传(假如Window Size = 1 [发送数据量是1])
含义:发送一个报文段，会这个报文段设置一次计时器，超时没收到确认时，重传该报文
发生阶段: 从握手开始，到TCP传输结束，整个生命周期都存在重传
	sender								Receiver
	Send 1(发送数据1)				-->		Receive 1(接收1)
	接收要求						<--		Send ACK 2(要求发送数据2)
	Send 2(发送数据2)				-->		Receive 2(接收2)
	接收要求						<--		Send ACK 3(要求发送数据3)
	...
	end(数据传完)

假设 1028 端口 向 23 端口发送数据包
格式: Soucre|Dest.|Sequence|Ack.|...
	Host A [1028] 						Host B [23]
	1028|23|10|0|...			-->	
	[Soucre、Sequence:随机产生 Ack.: 暂时还没有]	
								<--		23|1028|1|11|...
	1028|23|11|2|...			-->		
								<--		23|1028|2|12|...

# TCP 可靠传输机制--窗口流控[Window Size](假设 Receiver Window Size = 2)
含义:通过 Receiver 缓存的大小，调整 Window Size
	sender								Receiver
	WindowSize=3				-->		R
	Send 1
	WindowSize=3				-->		R
	Send 2
	WindowSize=3				-->		x(丢弃 Send 3)
	Send 3
	[一次发送三个数据包，发送滑动窗口为3]		[接收者缓存只有2，会丢弃3]
								<-- 	Ack 3
										Window size = 2
										[请求第三个报文段，并告诉发送者Window size = 2]
	WindowSize=2				-->		R
	Send 3
	WindowSize=3				-->		R
	Send 4
	[调查Window size，调整发送量]


# 连接终止的四次握手[可有A发起，也可由B发起]
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。 
简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
1.服务器读通道关闭
2.客户机写通道关闭
3.客户机读通道关闭
4.服务器写通道关闭
关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。
详细过程：
    第一阶段   客户机发送完数据之后，向服务器发送一个FIN数据段，序列号为i；
    1.服务器收到FIN(i)后，返回确认段ACK，序列号为i+1，关闭服务器读通道；
    2.客户机收到ACK(i+1)后，关闭客户机写通道；
   （此时，客户机仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据）
    第二阶段 服务器发送完数据之后，向客户机发送一个FIN数据段，序列号为j；
    3.客户机收到FIN(j)后，返回确认段ACK，序列号为j+1，关闭客户机读通道；
    4.服务器收到ACK(j+1)后，关闭服务器写通道。
这是标准的TCP关闭两个阶段，服务器和客户机都可以发起关闭，完全对称。
FIN标识是通过发送最后一块数据时设置的，标准的例子中，服务器还在发送数据，所以要等到发送完的时候，设置FIN（此时可称为TCP连接处于半关闭状态，因为数据仍可从被动关闭一方向主动关闭方传送）。如果在服务器收到FIN(i)时，已经没有数据需要发送，可以在返回ACK(i+1)的时候就设置FIN(j)标识，这样就相当于可以合并第二步和第三步。



TCP 存在粘包问题
缓冲传输、流量控制(窗口机制)

## UDP 报文格式
位置 名称(英文名) 					  长度/比特(bit)
1：	源端口(Source port)		 	  16			
2： 目标端口(Destination port)      16	
3： 长度(length)					  16
4： 校验和(Checksum) 				  16
5： 数据(Data) 					if any
__________________________________________________________________	
1--4：从上面到这里固定长度8 Bytes
__________________________________________________________________

### 网际互联层
[IP、ICMP、IGMP]

## IP 报文格式
位置 名称(英文名) 					  			长度/比特(bit)
1：	版本(Version)		 	  				4	
2：	头长度(Header Length)		 	  			4	
3：	优先级及服务类型(Priority&Type of Sevice)	8	
4：	总长度(Total Length)		 	  			16	
5：	标识(Identification)		 	  			16	
6：	标志(Flags)		 	  					3	
7：	段偏移(Fragment offset)		 	  		13	
8：	存活时间(Time to live)		 	  		8	
9：	协议(Protocol)		 	  				8	
10：	头校验和(Header checknum)		 	  		16	
11：	源IP地址(Source IP Address)		 	  	32	
12：	目的IP地址(Destination IP Address)		32	
13：	选项(Options)		 	  			0 or 32 if any	
14：	数据(Data)		 	  				varies if any
__________________________________________________________________
优先级及服务类型：服务类型QOS
标识、标志、段偏移：数据包分段用，当上层传下来的数据包比较大，经过的网络的MTU 较小，这时需要数据包分段。用这三个进行分段
存活时间(TTL):防止数据包在网络中无限传输,TTL值，这个值每经过一个路由器将会减1，路由器接收到 TTL 值为 0 的数据包将直接丢掉
协议：上层协议，TCP、UDP、ICMP
数据：传输层传下来的数据包
1--12：从上面到这里固定长度20 Bytes

版本 4bit IPv4 值为 4，IPv6 值为 6

网际校验和：端到端的校验和 16 位字序列(2个字节，数据字节数是奇数，则在末尾不一字节0，凑成偶数)对这些序列反码求和，便得校验和。
????
反码算数运算：两个数进行二进制反码求和的运算很简单。它的规则是从低位到高位逐列进行计算。0和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加1。

网际校验和算法：

在发送方，先把被校验的数据划分为许多16位字的序列。如果数据的字节长度为奇数，则在数据尾部补一个字节的0以凑成偶数。用反码算数运算把所有16位字相加后，然后再对和取反码，便得到校验和。

在接收方，将收到的数据报（包括校验和字段），将所有16位字再使用反码算数运算相加一次，将得到的和取反，即得出校验和的计算结果。如果数据报在传输过程中没有任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。

“A,B,C,...,Y,Z”分别表示一系列8位组，用[A,B]这样形式的字节组来表示A*256+B的整数，那么该字节序列的反码和就可以通过以下两种表达式之一给出：

[A,B] +' [C,D] +' ... +' [Y,Z]

[A,B] +' [C,D] +' ... +' [Z,0]

其中，+' 表示反码算数运算相加，第一个公式适用于偶数个字节的校验和，第二个公式适用于计算奇数个字节的校验和。

__________________________________________________________________	

## ICMP 协议[因特网控制报文协议]
不同报文
1、目的不可达ICMP协议(目的网络、主机、协议、端口，不可达[到达目的找不到])
2、超时ICMP报文
3、重定向ICMP报文(向源主机通知更好的路由)
4、ICMP回应请求和回应应答(ping 是ICMP 协议)

ICMP 协议 -- ping 
ping 成功说明：
1、源到目的节点，目的到源节点 都存在工作路径，目标IP对应的机器正常工作
2、源到目的的路径与目的到源的路径可能不一致，即不对称路由

ICMP 协议 -- Traceroute
测试网络连通性和测试从源到目的地址的详细路径(经过的路由器)
原理:(默认最多发送30次)
发送第一次，TTL=1 源-> 路由器1 TTL-1 -> TTL == 0， 丢弃，向源发送 ICMP 超时 -> 源记录 路由器1 地址
发送第二次，TTL=2 源-> 路由器1 TTL-1 转发给路由器2 ->  路由器2 TTL-1 -> TTL == 0， 丢弃，向源发送 ICMP 超时 -> 源记录 路由器2 地址
发送第N次，TTL=N 源-> 路由器1 TTL-1 转发给路由器2 ->  路由器2 TTL-1 ... 转发给路由器N-> TTL == 0， 丢弃，向源发送 ICMP 超时 -> 源记录 路由器N 地址
发送第N+1次，TTL=N+1，目的地址不认识的包 -> ... -> 到达目的地，目的节点向源发送目的不可达ICMP协议，源知道自己到达最终目标
源知道各个路由器的地址 
每次发送，三个数据包，接收到一份返回的 ICMP 报文，打印一个往返时间，如果5s内扔未收到3份数据包的任何一份响应，则打印一个星号

## IP地址分类
网络位[网段]+主机位=32=IP地址
---------------------------------------------------------------------------------------------------
网络类型 |	最大网络数	|	IP地址范围					| 最大主机数 |	私有IP地址范围
---------------------------------------------------------------------------------------------------
	A   | 126(2^7-2)	| 1.0.0.0--126.255.255.255		| 2^24-2    | 10.0.0.0--10.255.255.255
	B   | 16384(2^14)	| 128.0.0.0--191.255.255.255	| 2^16-2	| 172.16.0.0--173.31.255.255
    C   | 2097152(2^21)	| 192.0.0.0--223.255.255.255	| 2^8-2		| 192.168.0.0--192.168.255.255
    D   | 				| 224.0.0.0--239.255.255.255	| 			| 
    E   | 				|  								| 			|  
---------------------------------------------------------------------------------------------------
私有地址不能在公网使用，在企业内部使用
IP地址 127.x.x.x：本地回环(loopback)测试地址
广播地址:255.255.255.255(所有主机)
IP地址0.0.0.0:代表任何网络
某网段的主机位全是0的(x.0.0.0)：网络本身(Network ID),本网络的网络地址，不能分配
某网段的主机位全是1的(x.255.255.255)：当前网络的广播地址，不能分配
最大主机数：2^N-2,其中的2一个是网络地址本身，一个是广播地址

各类IP地址二进制的特征		|所占总数百分百|范围:
A: 0---(0开头的所有IP)  	| 1/2 		  [1--126,因为0和127是保留位]
B: 10--(10开头的所有IP) 	| 1/4 		  [128--191]
C: 110-(110开头的所有IP)  | 1/8 		  [192--223]
D: 1110(110开头的所有IP)  | 1/8 		  [224--239]

## IP 子网划分 -- 子网掩码
原理：将网络位变长，主机位变短。将一个大网络划分为多个小网络
子网掩码:区分网络位和主机位(二进制中，子网掩码1对应的是网络位，子网掩码是0对应主机位)
子网位=现网络位-原网络位=原主机位-现主机位
子网数=2^子网位 
主机数：2^主机位-2
所有子网: (规则) 原网络位不变，现在主机位全0，子网位从全0到全1
192.168.10.0/27[IP/网络位数]
网络地址：第一个IP地址
广播地址：最后一个IP地址

将一个C类网络 192.168.10.0 划分多个子网，要求至少22台主机，最多划分多少个子网，子网掩码是多少,写出所有子网
22 < 32-2 (2^5=32),即主机位为5位。
子网划分:2^N [N = 8(原来主机位) - 5(现在主机位) = 3]  = 8个子网
子网掩码: 后面8位为 111000(二进制) = 224 -> 255.255.255.224
所有子网:
	192.168.10.[000 00000] -> 192.168.10.0/27
	192.168.10.[001 00000] -> 192.168.10.32/27
	...
	192.168.10.[111 00000]

将一个145.34.0.0 IP 划分至少56个子网，每个子网至少60台主机，怎样策略划分
2^N >= 60 -> N 的取值为 6[2^6=64>60] -> 现主机位至少6位
2^X >= 56 -> X 的取值为 6[2^6=64>56] -> 子网位至少6位
145.34.0.0/16 -> 原主机位 = 32-16=16
现主机位 + 子网位 = 12 < 16
这样，现主机位 + 子网位 小于 原主机位，那么以现主机位为准的分配策略。是因为，主机位已经满足需要了，可以划分出更多的子网，避免浪费
所以划分为：26网络位+6主机位，子网掩码 255.255.255.192


### 链路层 
[硬件接口、ARP、RART]
ARP、RART:介于链路层和网络层的协议，只是归纳与链路层

## ARP 协议[地址解析协议]
作用：通过对方的IP地址来获取对方的MAC地址
数据从高层封装到数据链路层，需要封装目的MAC，由于源设备不知道目的MAC地址，需要通过ARP获取目的地址(向网络广播寻求目的IP对应的目标MAC地址)

## RARP 协议[反向地址解析协议]
作用：将MAC地址映射为IP地址
当PC不知道自己的IP地址时，通过向广播发送网络信息，寻求提供IP地址
例：无盘工作站，(PC关机IP 地址都存在硬盘中，没有操作系统和硬盘的PC，在启动时，向网络广播，寻求IP地址，当无盘工作站接收到广播时，向数据库查找该PC的MAC地址对应的IP地址，返回给PC，PC使用IP地址和无盘工作站进行通信，下载操作系统，安装启动)

MTU:最大传输单元，以太网(1500字节) IEEE802.3(1492字节)
数据长度比链路层MTU，IP层就要进行分片，每一片都小于MTU
路径MTU ：每个网络的链路层可能有不同的MTU，两个通信主机路径中，最小的MTU(传输过程某个环节要进行分片)
分片会降低以太网传输效率

以太网帧格式：
1-目的地址 (6): MAC 地址
2-源地址(6): MAC 地址
3-类型(2):三种类型

类型:三种类型[0800:IP数据报 0806:ARP请求/应答 8035:RARP请求/应答]。当数据从下层往上传输时，到链路层时，选择往上传递，到底是传递给网络层、ARP、还是RARP。是根据以太网帧的类型来选择，然后去掉头部，传向目的地。

以太网的帧MTU(最大传输单元)1500字节，最小是46个字节，不足则补全
CRC：帧的尾部
用于以太网的ARP请求或应答分组格式
|以太网目的地址|以太网源地址|帧类型|硬件类型|协议类型|硬件地址长度|协议地址长度|op|发送端以太网地址|发送端IP地址|目的以太网地址|目的IP地址|
|<-------以太网首部 14字节 --->|<------------------------- 28字节ARP请求/应答 ----------------------------------------->|

ARP
Host1向Host2发送数据，在封装到数据链路层，向ARP缓冲区寻求目标IP地址映射的MAC地址，发现没有，则向网络中的所有主机广播。目标IP对应的主机收到广播，将回复MAC地址。Host1收到MAC地址后，将IP和MAC对应关系存入 ARP高速缓冲区中。并将目标MAC地址写入以太网帧中(数据成帧)

Host1 ping Host2 域名
先 DNS域名解析 将 域名转换为 32位ip，然后封装 ICMP 数据包，数据在传输到下层时，需要Host2 的48位MAC地址，没有在 本地缓冲区找到 IP映射时，通过 ARP 协议，向网络广播寻求 Host2 的MAC 地址。然后 Host2 收到 ARP广播请求，响应 Host1。Host1 接收到响应，则拿到目标的MAC地址，然后封装到 ICMP 数据包。然后将 数据包发送到 Host2。

### 对等通信
每个层都有自己的协议。对等层传输的数据称为逻辑流

### 路由:
搜索匹配的主机地址 : 同一个网段
搜索网络地址	    : 不在同一个网段，先去找
搜索默认表项		:
假如 192.168.10.22 ping 192.168.0.22, 首先不在同一个网段中，则跳过匹配主机，去搜索网络地址，查找 192.168.0 有没有这个路由，如果没有，则去找默认网关的路由。再找不到，说明目标不可达

### 滑动窗口协议
用于链路层和传输层
区别: 
链路层确认是以帧为单位的
传输层确认是以字节位单位的























end
http://www.cnblogs.com/Jessy/p/3535612.html
http://www.cnblogs.com/fengzanfeng/articles/1339347.html