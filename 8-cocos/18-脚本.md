# 脚本

![Lua堆栈](18/Lua堆栈.png)

#### Lua 的 C 函数接口

> 宿主程序需要向 Lua 注册一个 C 函数的地址。 <br />
> 当Lua 调用 C 函数时，被调用的函数会得到一个新的栈(Lua为每一次C函数调用都分配一个独立的栈) ，<br />
> 首先要调用的函数被压入堆栈，<br />
> 接着把需要传递给这个函数的参数按正序压入栈 <br />
> 最后调用 lua_call() 方法。(调用需指明参数的个数) <br />
> 当函数调用完毕，所有的参数及函数本身都会出栈，而函数的返回值则被压入栈。(返回多个值正序压栈)
> 它里面包含了所有Lua传递给C函数的参数，而C函数则要将返回的结果也放入堆栈以返换给调用者。 

```c++
    // 获取栈顶元素，argc 为参数的个数
    int argc = lua_gettop(tolua_S) - 1;
```

> 在启动引擎时调用绑定代码向 Lua 虚拟机注册 <br />
> Cocos2d-x 中，Lua 虚拟机由 LuaEngine 管理

```c++
    auto engine = LuaEngine::getInstance();
    ScriptEngineManager::getInstance()->setScriptEngine(engine);

    // register custom function
    lua_State* L = engine->getLuaStack()->getLuaState();
    register_custom(L);

    /**
        程序启动时，LuaEngine 会调用register_custom(L),将register_custom(L)中的对象注册到Lua虚拟机中，这样Lua就能调用自定义对象的方法
    */

```

Node 实例:

```c++
    int lua_cocos2dx_Node_create(lua_State* tolua_S)
    {
        int argc = 0;
        bool ok true;
        argc = lua_gettop(tolua_S) - 1;
        if(argc == 0){
            if(!ok)
                return 0;

            Node* ret = Node::create();
            // 堆栈、类型、实例
            object_to_luaval<Node>(tolua_s, "cc.Node", (Node*)ret);
            return 1;
        }
        return 0;
    }
```

> 在 Lua 中调用 cc.Node:create() 时将执行lua_cocos2dx_Node_create()。 <br />
> 然后调用原生的 Node::create() 方法创建一个 Node* ret 对象。<br />
> object_to_luaval<Node>() 是为 ref 实例构建一个 userdata 对象来在 Lua 中引用其内存地址，并从注册表中查找该类型 metatable,让该对象拥有其表示类型的 metatable。

Lua 面向对象:

```lua
function class(classname, super)  
    local superType = type(super)  
    local cls  
  
    --如果提供的super既不是函数，也不是table，那么就直接将super当做不存在  
    if superType ~= "function" and superType ~= "table" then  
        superType = nil  
        super = nil  
    end  
  
    --如果有提供super  
    if superType == "function" or (super and super.__ctype == 1) then  
        -- 定义一个table，它将作为类的定义  
        cls = {}  
  
        --如果super是table，那么将super中定义的字段先全部拷贝到cls中  
        --然后将__create方法指定为super的__create方法  
        if superType == "table" then  
            -- copy fields from super  
            for k,v in pairs(super) do cls[k] = v end  
            cls.__create = super.__create  
            cls.super    = super  
        else   
        --这里提供的super时函数，那么也就是用这个方法来构造对象，那么直接将__create方法指向super  
            cls.__create = super  
        end  
  
        --提供一个空的ctor构造函数  
        cls.ctor    = function() end  
        cls.__cname = classname  
        cls.__ctype = 1  
  
        --定义.new(...)方法，他用户构建对象，首先是调用__create方法来构建一个table对象，然后将cls里面定义的字段全部拷贝到创建的对象中  
        --接下来在调用ctor构造方法  
        function cls.new(...)  
            local instance = cls.__create(...)  
            -- copy fields from class to native object  
            for k,v in pairs(cls) do instance[k] = v end  
            instance.class = cls  
            instance:ctor(...)  
            return instance  
        end  
  
    else  
        --从lua的类型中继承  
        if super then  
            cls = clone(super)  
            cls.super = super  
        else  
        --直接就没有super，那么定义cls为一个带有空ctor的table  
            cls = {ctor = function() end}  
        end  
  
        cls.__cname = classname  
        cls.__ctype = 2 -- lua  
        cls.__index = cls  
  
        --这里的new方法，首先是创建了空的table，然后将其metatable指向为cls  
        --然后在调用ctor构造方法  
        function cls.new(...)  
            local instance = setmetatable({}, cls)  
            instance.class = cls  
            instance:ctor(...)  
            return instance  
        end  
    end  
    --返回类型的定义  
    return cls  
end  

```
















END