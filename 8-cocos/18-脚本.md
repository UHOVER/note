# Lua 相关

#### Lua 的 数据类型
1、数值(number): 内部以double表示。 <br />
2、字符串(string): <br />
3、布尔(boolean): 只有 true 和 false <br />
4、函数(function): <br />
5、表(table): 异构的Hash 表 <br />
6、userdata: 定义的C数据结构，脚本只能使用它，不能定义。<br />
7、线程(thread):Lua协程(coroutine) <br />



#### metatable

####  c 绑定 lua

# 脚本

![Lua堆栈](18/Lua堆栈.png)

#### Lua 的 C 函数接口

> 宿主程序需要向 Lua 注册一个 C 函数的地址。 <br />
> 当Lua 调用 C 函数时，被调用的函数会得到一个新的栈(Lua为每一次C函数调用都分配一个独立的栈) ，<br />
> 首先要调用的函数被压入堆栈，<br />
> 接着把需要传递给这个函数的参数按正序压入栈 <br />
> 最后调用 lua_call() 方法。(调用需指明参数的个数) <br />
> 当函数调用完毕，所有的参数及函数本身都会出栈，而函数的返回值则被压入栈。(返回多个值正序压栈)
> 它里面包含了所有Lua传递给C函数的参数，而C函数则要将返回的结果也放入堆栈以返换给调用者。 

```c++
    // 获取栈顶元素，argc 为参数的个数
    int argc = lua_gettop(tolua_S) - 1;
```

> 在启动引擎时调用绑定代码向 Lua 虚拟机注册 <br />
> Cocos2d-x 中，Lua 虚拟机由 LuaEngine 管理

```c++
    auto engine = LuaEngine::getInstance();
    ScriptEngineManager::getInstance()->setScriptEngine(engine);

    // register custom function
    lua_State* L = engine->getLuaStack()->getLuaState();
    register_custom(L);

    /**
        程序启动时，LuaEngine 会调用register_custom(L),将register_custom(L)中的对象注册到Lua虚拟机中，这样Lua就能调用自定义对象的方法
    */

```

Node 实例: 

```c++
    int lua_cocos2dx_Node_create(lua_State* tolua_S)
    {
        int argc = 0;
        bool ok true;
        argc = lua_gettop(tolua_S) - 1;
        if(argc == 0){
            if(!ok)
                return 0;

            Node* ret = Node::create();
            // 堆栈、类型、实例
            object_to_luaval<Node>(tolua_s, "cc.Node", (Node*)ret);
            return 1;
        }
        return 0;
    }
```

> 在 Lua 中调用 cc.Node:create() 时将执行lua_cocos2dx_Node_create()。 <br />
> 然后调用原生的 Node::create() 方法创建一个 Node* ret 对象。<br />
> object_to_luaval<Node>() 是为 ref 实例构建一个 userdata 对象来在 Lua 中引用其内存地址，并从注册表中查找该类型 metatable,让该对象拥有其表示类型的 metatable。

Lua 面向对象: <br />

> lua 中没有类的概念，只有table表，而面向对象的实现是将表与父类的表连在一起，没有这个变量时去父类查找。<br / >
> 过程: <br />
> 建一个table cls <br />
> 1、如果有supers,设置父类 <br />
>   a、如果 super 是 function 类型，则将 cls.__create = super <br />
>   b、如果 super 是 table <br />
>       b1、且 父类是原生的cocos类，比如cc.Node，则 cls.__create 为调用 super:create() <br />
>       b2、父类是自定义的类，如 a = {},则 将他放进 cls.__supers <br />
> 
> 2、设置元表，将 父类设置为其元表 <br />
> 3、为 cls 设置一个默认的 构造函数(ctor) <br />
> 4、新建方法(xxx.new()) <br />
>   a、如果存在 __create,则通过 cls.__create 创建实例 <br />
>   b、否则 实例为 {} <br />
>   c、调用构造函数  <br />
>   

```lua
function class(classname, ...)     
    -- 参数一：要创建的类名称，参数二：父类-可选参数，可以是table，function，userdata等
    local cls = {__cname = classname}

    local supers = {...}   
    for _, super in ipairs(supers) do    -- 遍历父类
        local superType = type(super)
        -- 父类如果不是第一个参数表示的类型的话，就输出第二个参数
        if superType == "function" then
            -- 如果父类是个function的话，就让cls的create方法指向他
            cls.__create = super
        elseif superType == "table" then  
            -- 如果父类是table
            if super[".isclass"] then
                -- 如果父类是原生的cocos类，比如cc.Node，不是自己定义的类
                cls.__create = function() return super:create() end
            else
                -- 如果父类是自定义的类，比如 A = {}
                cls.__supers = cls.__supers or {}
                cls.__supers[#cls.__supers + 1] = super       -- 保存cls的多个父类的table表
                if not cls.super then
                    -- 将遍历到的第一个table作为cls的父类
                    cls.super = super
                end
            end
        else
            -- 如果父类既不是table，也不是function的话，报错。如果父类不存在，不会执行这个循环的，所以super可以为nil。
            error(...)
        end
    end
    -- 前面一大段是找到cls的所有父类；
    -- 接下来就是设置cls的元表了。
    -- 设置cls的第一索引对象是自己，如果实例对象找不到某个参数的话，
    --就会查找该类是否包含该参数，如果该类也不包含的话，就去父类查找
    cls.__index = cls   
    if not cls.__supers or #cls.__supers == 1 then  
        -- 如果cls只有一个父类，即单继承的话，设置cls的父类是他的元表
        setmetatable(cls, {__index = cls.super})
    else
        -- 如果cls是多重继承的话，__index为一个函数，找元素的时候就会执行一遍该函数
        setmetatable(cls, {__index = function(_, key)
            -- 遍历所有父类，查找key对应的值并返回
            local supers = cls.__supers
            for i = 1, #supers do
                local super = supers[i]
                if super[key] then return super[key] end
            end
        end})
    end

    if not cls.ctor then
        -- 增加一个默认的构造函数
        cls.ctor = function() end
    end
    cls.new = function(...)  -- 新建方法，这个也是比较重要的方法
        local instance
        if cls.__create then
            -- 如果有create方法，那么就调用，正常情况下，自定义的cls是没有create方法的。
            -- 通过__index和元表的index，一级一级往上找，直到找到原生cocos类
            instance = cls.__create(...)
        else
            instance = {}  -- 没有create方法，他是一个普通类
        end
        -- 设置instance的元表index，谁调用了new，就将他设置为instance的元类index
        setmetatableindex(instance, cls)
        instance.class = cls
        instance:ctor(...) --调用构造方法
        return instance
    end
    cls.create = function(_, ...)
        return cls.new(...)
    end

    return cls
end

```









END