# 脚本

![Lua堆栈](18/Lua堆栈.png)

#### Lua 的 C 函数接口

> 宿主程序需要向 Lua 注册一个 C 函数的地址。 <br />
> 当Lua 调用 C 函数时，被调用的函数会得到一个新的栈(Lua为每一次C函数调用都分配一个独立的栈) ，<br />
> 首先要调用的函数被压入堆栈，<br />
> 接着把需要传递给这个函数的参数按正序压入栈 <br />
> 最后调用 lua_call() 方法。(调用需指明参数的个数) <br />
> 当函数调用完毕，所有的参数及函数本身都会出栈，而函数的返回值则被压入栈。(返回多个值正序压栈)
> 它里面包含了所有Lua传递给C函数的参数，而C函数则要将返回的结果也放入堆栈以返换给调用者。 

```c++
    // 获取栈顶元素，argc 为参数的个数
    int argc = lua_gettop(tolua_S) - 1;
```

> 在启动引擎时调用绑定代码向 Lua 虚拟机注册 <br />
> Cocos2d-x 中，Lua 虚拟机由 LuaEngine 管理

```c++
    auto engine = LuaEngine::getInstance();
    ScriptEngineManager::getInstance()->setScriptEngine(engine);

    // register custom function
    lua_State* L = engine->getLuaStack()->getLuaState();
    register_custom(L);

    /**
        程序启动时，LuaEngine 会调用register_custom(L),将register_custom(L)中的对象注册到Lua虚拟机中，这样Lua就能调用自定义对象的方法
    */

```

Node 实例:

```c++
    int lua_cocos2dx_Node_create(lua_State* tolua_S)
    {
        int argc = 0;
        bool ok true;
        argc = lua_gettop(tolua_S) - 1;
        if(argc == 0){
            if(!ok)
                return 0;

            Node* ret = Node::create();
            // 堆栈、类型、实例
            object_to_luaval<Node>(tolua_s, "cc.Node", (Node*)ret);
            return 1;
        }
        return 0;
    }
```

> 在 Lua 中调用 cc.Node:create() 时将执行lua_cocos2dx_Node_create()。 <br />
> 然后调用原生的 Node::create() 方法创建一个 Node* ret 对象。<br />
> object_to_luaval<Node>() 是为 ref 实例构建一个 userdata 对象来在 Lua 中引用其内存地址，并从注册表中查找该类型 metatable,让该对象拥有其表示类型的 metatable。


















END