# 全新的绘制系统

> 在v2.x，Cocos2d-x每个元素的绘制逻辑均分布于每个元素内部的draw()方法里，并且紧密地依赖UI树的遍历。<br />
> 虽然通过SpriteBatchNode等机制可以使它目前仍然能高效地工作，但这却是一个不易扩展和优化的架构。<br />
> 例如，依赖UI树的遍历顺序导致无法在多个层级之间调整绘制顺序，各个绘制逻辑分布在每个元素内部不利于对绘制进行优化(如自动批绘制)，针对一些硬件平台的优化可能要修改多个元素的绘制逻辑等。

- v3.x绘制系统的特点

1、将绘制逻辑从主循环中分离。

> 游戏引擎的很大一部分工作是管理场景中的各种UI元素，如它们的坐标变换、UI树结构等。<br />
> 另一部分工作是分别绘制它们。

2、采用应用程序级别的视口裁剪

> 如果一个UI元素在场景中的坐标位于视窗区域之外，那么它根本不会将任何绘制命令发送到绘制栈上。<br />
> 这将减少绘制栈上绘制命令的数量，也将减少绘制命令的排序时间，还会减少对GPU的浪费(OpenGL ES 会在图元装配阶段将位于视口之外的图元丢弃或剪裁)

3、采用自动批绘制技术

> 减少OpenGL ES 的绘制次数(Draw Calls)能增强绘制性能。<br />
> 如果在一个场景中有很多元素都使用同一张纹理、同一个着色器程序等，理论上可以调用一次绘制命令。<br />
> 自动批绘制需要相关的绘制命令在执行顺序上相邻。

4、更简单地实现绘制的自定义

> 自定义绘制可以加入Cocos2d-x的绘制命令栈，参与所有命令的绘制排序。

- 绘制系统

绘制流程分三个阶段:生成绘制命令、对绘制命令进行排序、执行绘制命令

1、通过UI树的遍历给每个元素生成一个绘制命令

> 新的绘制系统实现的基础是将与绘制相关的部分从UI元素中分离。<br />
> RenderCommand 表示一个绘制类型，它定义了怎样绘制一个UI元素。<br />
> 一般情况下，每个UI元素会关联0个或1个RenderCommand，并在重写的Node::draw()方法中将绘制命令发送给render。<br />
> 示例: 如果一个特殊的UI元素需要执行一系列的绘制命令，可以使用特殊的GroupCommand来实现。<br />
> 例如，要实现将所有子元素绘制到纹理而不是屏幕上。

```c++
    void Sprite::draw(Renderer* renderer, const Mat4 &transform, bool transformUpdated)
    {
        // Don't do calculate the culling if the transform was not updated
        _insideBounds = transformUpdated ? renderer->checkVisibility(transform, _contentSize) : _insideBounds;

        if(_insideBounds)
        {
            _quadCommand.init(_globalZOrder, _texture->getName(), getGLProgramState(), _blendFunc, &_quad, 1, transform);
            renderer->addCommand(&_quadCommand);
        }
    }
```

Sprite的draw()方法演示绘制分离的方式。<br />
Sprite 在draw()方法中仅向renderer发送一个RenderCommand(QuadCommand)绘制命令。<br />
此时，它不会执行任何GL绘制命令，renderer会将RenderCommand放入一个栈中，等场景中的UI元素全部遍历完毕，renderer才开始执行栈中的所有RenderCommand。<br />

> 这样就将每个元素的绘制部分从UI树的遍历过程中抽取出来。<br />
> 统一处理所有绘制命令: <br />
> 1-使渲染系统可以针对绘制做一些优化，如针对相邻且使用相同纹理的AuadCommand执行自动批绘制。<br/>
> 2-可以灵活地调整不同UI层级之间的元素的绘制顺序。

2、绘制流程的第二个阶段是对绘制命令进行排序

> 待场景中的UI元素被全部遍历完成，renderer 开始执行栈上的命令。<br />
> 在执行之前，它会对栈上的绘制命令进行排序(中序遍历)，然后按新的顺序执行它们。<br />
> 所以，绘制命令被执行的顺序不一定是UI元素被遍历的顺序。<br />
> v3.x使用一个新的globalZOrder直接设置元素的绘制顺序。<br />
> 元素的绘制顺序首先由globalZOrder决定，然后才是按照元素的遍历顺序，这样就可以在不同层级的元素之间调整绘制顺序。

3、renderer 对经过排序的绘制命令执行绘制

> 对于一般的RenderCommand，按顺序执行。<br />
> 对于Sprite使用的QuadCommand，如果两个QuadCommand相邻且使用相同的纹理、着色器等，renderer会将它们组合成一个QuadCommand，这称为自动批绘制(Auto Batch)。 <br />
> 自动批绘制减少了绘制次数，提升了绘制性能。<br />
> 将绘制统一执行的好处就是系统能够根据一些条件对绘制做一些优化工作。

- RenderCommand

Cocos2d-x渲染系统管理下的每一次绘制调用都是一个RenderCommand，一个RenderCommand 是一种特定的绘制方式的封装。(QuadCommand、GroupCommand继承自RenderCommand)

> 例如，QuadCommand 根据 1 个纹理和 4 个顶点(Quad)绘制一幅图片，或一组OpenGL ES 绘制命令的封装。<br />
> 每个RenderCommand 所包含的OpenGL ES 命令会被放到一起按顺序执行。<br />
> 为了不影响其他RenderCommand的绘制，每个RenderCommand在结束后将对OpenGL ES 的一些状态进行还原，如自定义的摄像机修改了观察点的位置和方向等。<br />

一个UI元素可能使用1个或多个RenderCommand来绘制场景。

```c++
    // RenderCommand 定义
    class RenderCommand
    {
    public:
        enum class Type
        {
            UNKNOWN_COMMAND,
            QUAD_COMMAND,
            CUSTOM_COMMAND,
            BATCH_COMMAND,
            GROUP_COMMAND,
        };

        /** Get Render Command Id */
        inline float getGlobalOrder() const { return _globalOrder; }

        /** Returns the Command type */
        inline Type getType() const { return _type; }
    };

```

1、每个 RenderCommand 实例中包含一个 globalOrder 属性，它是用来决定绘制顺序的重要属性。<br />
为了正确反映场景中元素的层次，所有RenderCommand顺序的计算需要被小心地处理。

2、RenderCommand 的另一个属性是类型(Type)

Cocos2d-x 引擎内置多个RenderCommand类型:

QUAD_COMMAND: 用来绘制1个或多个矩形区域(如Sprite和ParticleSystem)。相邻的QuadCommand如果使用相同的纹理，则可以实现自动批绘制。<br />

BATCH_COMMAND: 用来绘制一个TextureAtlas，如Label、TileMap



























END