#### 是否每一帧渲染都会遍历UI树还有绘制
是
#### 绘制栈 RenderQueue 会每一帧都清理吗


Render 持有多个 RenderQueue
RenderQueue 中可能是 一组的 RenderCommand 或 一个 GroupCommand

绘制 GroupCommand，去找对应的 RenderQueue， 找到后执行其中 RenderCommand。


片段?

bpp：全称 "Bits per Pixel",表示每像素占据多少位
图像数据格式和占内存，RGB888(24 bpp) 是 RGBA8888(32 bpp) 的 3/4 ?
纹理所占内存大小 result = size.width X size.height X bpp/8

--

在Application::run()每个一定时间(帧率,如果一帧执行的时间没达到,固定时间,休眠直到固定时间)调用一次Director::mainLoop(),mainLoop则是一帧的逻辑

```c++
    void DisplayLinkDirector::mainLoop()
    {
        // 先绘制场景
        drawScene();
        // 清空 AutoreleasePool 
        PoolManager::getInstance()->getCurrentPool()->clear();
    }
```

> 帧开始-> 用户输入-> 动画计算-> 物理模拟-> 物理模拟完成-> 逻辑更新-> 更新完成-> UI树变量-> 遍历完成-> 绘制-> 绘制完成-> 交换缓冲区-> 自动释放  <br/>

帧开始->用户输入->动画计算->物理模拟->逻辑更新 <br />
-> ** UI树遍历 **  

> 在 Node::visit() <br />
> 0- 如果元素不可见 visible，则直接跳过visit()，不用计算和绘制该元素及其子元素。<br />
> 1- 将元素的相对坐标转换成世界坐标的模型视图变换矩阵。 <br />
>    - 父节点没有更改或之前已经计算过的不需要再重新计算。
> 2-先对子元素进行排序，根据 localZOrder 进行从小到大排序。<br />
>    - _reorderChildDirty == true 表示需要重新排序，只有在 addChild() 和 setLocalZOrder() _reorderChildDirty 才会变成 true <br />
> 3- 采用中序的深度优先算法进行遍历 <br />
>    - localZOrder 小于0 为左子树，自身为根，localZOrder 大于等于0为右子树 <br />
> 4- 遍历调用到自己，调用draw() 发送绘制命令
>   - 如果是超出屏幕范围，则不需要调用 draw()
>   - _trianglesCommand.init(_globalZOrder...); // 初始化一个 RenderCommand
        renderer->addCommand(&_trianglesCommand); // 根据 globalZOrder 大于0、等于0、小于0， 将 command 放置到RenderQueue 对应的队列中 
    - RenderQueue 等于0 的队列在绘制时是不需要重新排序的

-> ** 绘制 ** 

> 绘制流程分为三个阶段: <br />
> 1- 生成绘制命令 <br />
>       通过UI树遍历给每个元素生成一个绘制命令 RenderCommand <br />
> 2- 对绘制命令进行排序 <br />
>       绘制命令被保存在 RenderQueue 绘制命令队列中。<br />
>       RenderQueue 维护三个数组，分别是 globalZOrder 小于0、等于0、大于0 <br />
>       默认的 Node 的 globalZOrder 等于，所以等于0 的数组不用进行排序，直接按命令发送的顺序(localZOrder) 进行绘制，对小于0、大于0的数组进行排序 RenderQueue:sort() <br />
>       每一帧都会对渲染队列进行排序，所以为了性能考虑，少用或者不用 globalZOrder <br />
> 3- 执行绘制命令 <br />
>    在 Renderer::render() 进行排序后，渲染主绘制队列 visitRenderQueue(_renderGroups[0])，在主绘制队列中，中序深度优先遍历进行渲染，globalZOrder 小于0、等于0、大于0<br />   
>    如果两个QuadCommand相邻且使用相同的纹理、着色器等，Renderer会将它们组合成一个QuadCommand 进行自动批处理绘制。<br />
>    自动批处理绘制: 遇到第一个command 时不会立即绘制，而是将其放到一个数组中缓存起来，然后继续迭代后面的command,如果遇到第二个command,相同的type和相同的材料，则添加到缓存数组中。不同，则先绘制之前缓存的command。
>       

-> ** 交换缓冲区 **

> 视图系统提供的帧缓冲的颜色缓冲区通常由两个缓冲对象组成，分别是一个前端缓冲和一个后端缓冲。<br />
> 前面的所有内容首先绘制到后端缓冲区，然后到绘制完成后，也就是一帧的后面，通过交换缓冲区，将新的内容显示在屏幕上。<br />
> 之后，前端缓冲变成后端缓冲，而后端缓冲变成前端缓冲。<br />

-> ** 自动释放 **

> AutoreleasePool 一帧被清理一次，主要用来清理UI元素，因为UI元素大部分添加到UI树中，会一直占用内存。<br />

* 上传纹理 *

> Cocos2d-x的纹理异步加载回调使用了一个自定义的Schedule。<bt />
> 在该Schedule内部，检查已经完成加载的纹理，每一帧处理一个纹理，通过glTexImage2D 将纹理上传值GL内存。直至所有纹理被处理完毕，则注销该Schedule。


--

性能优化: 

> 1- 散图合成，增加自定批绘制的可能行。 <br />
> 2- 尽量不要设置 globalZOrder, 在渲染时，默认的globalZOrder(0) 不需要重新排序
> 3- Cocos2d-x 默认是单线程为主，会开启一个新的线程异步加载纹理

--

透明图片还是半透明图片会消耗性能


--

加密图片资源

> 将图片的二进制数据读取到数据中，因为Png、Jpg的头是一样的，所以在加密时，将它的头部信息去掉，并加有某些标识，在解密时，当读取到这些标识，将头部信息再加回去就行。

```c++
bool Image::initWithImageFile(const std::string& path)
{
    bool ret = false;
    _filePath = FileUtils::getInstance()->fullPathForFilename(path);
    Data data = FileUtils::getInstance()->getDataFromFile(_filePath);

    if (!data.isNull())
    {
        ret = initWithImageData(data.getBytes(), data.getSize());
    }

    return ret;
}

bool Image::initWithImageData(const unsigned char * data, ssize_t dataLen)
```

--