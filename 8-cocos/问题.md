#### 是否每一帧渲染都会遍历UI树还有绘制
#### 绘制栈 RenderQueue 会每一帧都清理吗


Render 持有多个 RenderQueue
RenderQueue 中可能是 一组的 RenderCommand 或 一个 GroupCommand

绘制 GroupCommand，去找对应的 RenderQueue， 找到后执行其中 RenderCommand。


片段?

bpp：全称 "Bits per Pixel",表示每像素占据多少位
图像数据格式和占内存，RGB888(24 bpp) 是 RGBA8888(32 bpp) 的 3/4 ?
纹理所占内存大小 result = size.width X size.height X bpp/8

--

在Application::run()每个一定时间(帧率,如果一帧执行的时间没达到,固定时间,休眠直到固定时间)调用一次Director::mainLoop(),mainLoop则是一帧的逻辑

```c++
    void DisplayLinkDirector::mainLoop()
    {
        // 先绘制场景
        drawScene();
        // 清空 AutoreleasePool 
        PoolManager::getInstance()->getCurrentPool()->clear();
    }
```

> 帧开始-> 用户输入-> 动画计算-> 物理模拟-> 物理模拟完成-> 逻辑更新-> 更新完成-> UI树变量-> 遍历完成-> 绘制-> 绘制完成-> 交换缓冲区-> 自动释放  <br/>

帧开始->用户输入->动画计算->物理模拟->逻辑更新 <br />
-> ** UI树遍历 **  

> 在 Node::visit() <br />
> 0- 如果元素不可见 visible，则直接跳过visit()，不用计算和绘制该元素及其子元素。<br />
> 1- 将元素的相对坐标转换成世界坐标的模型视图变换矩阵。 <br />
>    - 父节点没有更改或之前已经计算过的不需要再重新计算。
> 2-先对子元素进行排序，根据 localZOrder 进行从小到大排序。<br />
>    - _reorderChildDirty == true 表示需要重新排序，只有在 addChild() 和 setLocalZOrder() _reorderChildDirty 才会变成 true <br />
> 3- 采用中序的深度优先算法进行遍历 <br />
>    - localZOrder 小于0 为左子树，自身为根，localZOrder 大于等于0为右子树 <br />
> 4- 遍历调用到自己，调用draw() 发送绘制命令
>   - 如果是超出屏幕范围，则不需要调用 draw()
>   - _trianglesCommand.init(_globalZOrder...); // 初始化一个 RenderCommand
        renderer->addCommand(&_trianglesCommand); // 根据 globalZOrder 大于0、等于0、小于0， 将 command 放置到RenderQueue 对应的队列中 
    - RenderQueue 等于0 的队列在绘制时是不需要重新排序的

-> ** 绘制 ** 

> // TODO

-> ** 交换缓冲区 **

> 视图系统提供的帧缓冲的颜色缓冲区通常由两个缓冲对象组成，分别是一个前端缓冲和一个后端缓冲。<br />
> 前面的所有内容首先绘制到后端缓冲区，然后到绘制完成后，也就是一帧的后面，通过交换缓冲区，将新的内容显示在屏幕上。<br />
> 之后，前端缓冲变成后端缓冲，而后端缓冲变成前端缓冲。<br />

-> ** 自动释放 **

> AutoreleasePool 一帧被清理一次，主要用来清理UI元素，因为UI元素大部分添加到UI树中，会一直占用内存。<br />


--

性能优化: 

> 1- 散图合成，增加自定批绘制的可能行。 <br />
> 2- 尽量不要设置 globalZOrder, 在渲染时，默认的globalZOrder(0) 不需要重新排序
> 3- Cocos2d-x 默认是单线程为主，会开启一个新的线程异步加载纹理

--