# 纹理

> 3D 图形渲染最重要的工作之一是将纹理应用到物体表面，这个过程主要发生在片段着色器工作的阶段，使光栅化阶段插值计算得出的纹理坐标从纹理中采样，然后对片段进行着色，可以处理丰富的特效，如光照、阴影等。<br />
> 纹理是其实现的重要基础。<br/>
> 
> 纹理的存储格式影响着应用程序包的大小，也占据了应用程序的大部分内存。<br />
> Cocos2d-x 通过 Texture2D 类来创建和管理 OpenGL ES 纹理。<br />
> Texture2D 类讲述 纹理的格式、多级纹理、纹理绑定以及怎样在内存中管理纹理、各种压缩纹理格式的处理方法。

- 光栅化

在 OpenGL ES 2.0 的绘图管线中，光栅化阶段用于将投影到 2D 屏幕上的图元转换为帧缓冲中整数坐标位置上的片段，<br />
每个片段都会包含颜色、深度和模板值。

光栅化分为两个步骤:

> 1) 确定视窗上哪些整数位置的片段需要被图元覆盖。<br />
> 2) 对图元进行插值计算，得出每个片段的颜色和深度。 这些颜色和深度值被送入后续的阶段(片段操作，Per-Fragment Operations) 进行处理，最后的结果将用于更新帧缓冲上该位置的信息。

每个片段的颜色值由片段着色器决定，片段着色器会使用光栅化生成的一些易变(Varying) 变量。

> 例如，纹理坐标等用于计算颜色值，片段的深度值则由光栅化决定。

1、多重采样

> 反锯齿(Anti-aliasing) 也称抗锯齿或边缘柔化，是一种用于消除显示器输出的画面中图像边缘出现锯齿的技术。<br />
> 
> 那些锯齿通常是因为高分辨率信号以低分辨率表示或无法准确运算出3D图形坐标所导致的图形混叠而产生的。

在光栅化的过程中，由于屏幕是由离散的像素点组成的，所以在对图元进行采样时可能会丢失一部分，导致其边缘出现锯齿。<br />

默认(不开启多重采样) Cocos2d-x 中使用 DrawNode 绘制的倾斜的线段，像素之间过渡非常生硬，出现了比较明显的锯齿。<br />

在 OpenGL ES 中使用多重采样(MultiSampling)技术解决锯齿问题，与单重采样不同，帧缓冲上的每个像素不是来自单个片段中心位置的采样，而是基于附近多个位置的采样共同决定的一个颜色值。<br />
因此，相对于单重采样，帧缓冲额外的多重采样缓冲区来存储这些额外采样点的颜色、深度和模板值，这就使图元的边缘能够比较平滑地过渡，从而减小这种视觉的瑕疵。<br />

Cocos2d-x默认不开启多重采样，需要通过手动修改 CCEAGLView 的初始化方法的 multiSampling 参数来开启。

```c++
    /**
        multiSampling 参数的值设为 YES，则Cocos2d-x开始多重采样在DrawNode 中使用
        numberOfSamples 为每个片段包含的邻近采样点的数量，数量越多，抗锯齿的效果越明显，
        相应地也影响性能。
        这个最大数量受硬件支持的限制，可以通过 getIntegerv(GL_MAX_SAMPLES)来查询当前硬件支持的最大数量
    */
    - (BOOL) application:(UIApplication*)application didFinishLaunchingWithOptions: (NSDictionary*)launchOptions
    {
        CCEAGLView* eaglView = [CCEAGLView viewWithFrame: [window bounds]
        pixelFormat: kEAGLColorFormatRGBA8
        depthFormat: GL_DEPTH24_STENCIL8_OES
        preserveBackbuffer: NO
        sharegroup: nil
        multiSampling: NO
        numberOfSamples: 0];
    }
```

在一般2D游戏中，由于大部分精灵都是规则且垂直于摄像机的矩形区域，所以锯齿现象不是很明显。<br />
但是，如果游戏中需要绘制一些不规则的线段或多边形，则最好开启多重采样。<br />

> 注意: <br />
> 开启多重采样后，缓冲区的像素信息不再被存储到帧缓冲中，而是被存储到一个特殊的多重采样的缓冲区中。<br />
> 多重采样只能在初始化 OpenGL ES 时设置，之后不能被修改，<br />
> 这是因为多重采样与单个像素点采样在实现机制上有很大的区别。<br />
> OpenGL ES 中的多重采样只是针对多边形的边缘进行抗锯齿处理，对应用程序性能的影响相对比较小。

2、纹理坐标

OpenGL ES 纹理坐标以纹理的左下角为坐标原点，有两种度量形式:

> 1) 顶点在纹理中的纹理坐标通常用(u,v) 表示，分别是纹理的宽度和高度，由客户端应用程序提供
> 2) 在片段着色器中使用片段纹理坐标通常用(s,t)表示，取值范围(0.0,0.0)~(1.0,1.0)

- 像素矩形

像素矩形(Pixel Pectangles) 表示一个矩形区域的二维像素数组。<br />
它可以用来表示一个矩形区域的颜色、深度或者模板值，对应其数组的每个像素值分别表示颜色、深度和模板。

> 存储颜色值的像素矩形可以通过 TexImage2D 及相关命令定义，并将数据由客户端内存中传输至 GL 服务端内存中，或通过 ReadPixels 及相关命令将数据从帧缓冲区中读取到客户端内存中。<br />
> 
> 将客户端的颜色数据传输至GL服务端的过程成为解包(Unpack) <br />
> 将服务端像素矩形中的像素数据读取到客户端的过程称为打包(Pack)

通过TexImage2D及相关命令定义的像素矩形称为纹理。<br />
纹理由纹理像素(Texels)组成，简称纹素。<br />

> 一个2D纹理由一个二维的纹理数组组成，纹理的宽度表示数组的列数，高度表示数组的行数，<br />
> 数组中的第一个元素表示纹理左下角的像素点。<br />
> 3D 纹理在 2D 纹理上增加一个深度(Depth)，它由一个三维的纹理像素数组组成。

1、像素存储模式:

> 在纹理的传输过程中，所有用于控制客户端中的纹素编码的参数都使用 PixeStorei 命令 "void PixelStorei(enum pname, T param);" 设置。 <br />
> PixeStorei 命令会影响 TexImage2D、ReadPixels 及其他像素矩形数据传输相关的命令。<br />

```c++  
    参数名称        类型      初始值     合法值
UNPACK_ALIGNMENT  integer    4       1,2,4,8
```

2、纹理数据的传输

客户端内存中的像素数据传输到 GL 内存中的过程称为解包(Unpacking) <br />
其中输入是客户端内存中以某种方式编码的像素数据，输出是取值 [0, 1] 的浮点型 RGBA 像素值。<br />
按照这个传输过程的顺序解释纹理数据的传输。<br />

任何传输或者返回像素矩形的命令都需要包含一些基本参数(特定的传输过程还需要额外的参数，如 glTexImage2D) <br />
如 format、width、height、data、type

> format: <br />
> format 用来表示一个像素矩形中数据的构成。<br />
> 在内存中，data 是一个 ubyte 或 ushort 数组，数组中的元素被按 1、2、3或4个分量(Component)形成一个组(Group) 的集合。<br />
> 因此，format 就描述了每个组的构成，包括每个分量的构成及顺序。<br />
> 按照类型，一个像素矩形可能表示的是颜色值、深度值、模板值，以及深度与模板共同构成的数据值。<br />
> 一个颜色值最多由4个分量构成，深度值和模板值由一个分量构成，深度与模板共同构成的数据值则由2个分量构成。

```c++
    // 像素矩形传输的格式名称及意义
    格式名称(format)    分量意义及顺序     目标缓冲区
    ALPHA              A                Color
    RGB                R,G,B            Color
    RGBA               R,G,B,A          Color
    LUMINANCE          Luminance        Color
    LUMINANCE_ALPHA    Luminance,A      Color

    //
    data: 是 ubyte 或 ushort 数组
    数组的元素是一个组的集合
    组有 1~4个分量
    format 描述 组的构成、分量的构成及顺序
    一个颜色值最多由4 个分量构成
    深度值和模板值是 1个分量
    深度与模板共同构成的数据值 是 2 个分量构成
```

> data: <br />
> 表示客户端内存中像素矩形数组的指针，也可能是指向一个缓冲对象的偏移值。 <br />

> type 参数的可选类型

```c++
    // 分量的位数及GL数据类型
    // type 每个像素分量的构成(左) 以及data数组中每个元素的数据类型(右)，它只能为ubyte或ushort 数据类型
    类型(type)枚举          GL数据类型
    UNSIGNED_BYTE          ubyte
    UNSIGNED_SHORT_5_6_5   ushort
    UNSIGNED_SHORT_4_4_4_4 ushort
    UNSIGNED_SHORT_5_5_5_1 ushort

```

> 对于表示颜色的像素矩形，每个分量(R、G、B和A)在数组中所占的位数可能不同

3、解包

> format 描述了像素矩形的数据类型(颜色、深度或模板)。<br />
> type 定义了像素数据分量的构成，<br />
> 因此所有编码格式的像素矩形的数量由 format 和 type 共同决定。

```c++
    // OpenGL ES 支持的所有像素格式和类型的组合
    格式名称(format)    类型(type)枚举          bytes/pixel
    RGBA               UNSIGNED_BYTE           4
    RGB                UNSIGNED_BYTE           3
    RGBA               UNSIGNED_SHORT_4_4_4_4  2
    RGBA               UNSIGNED_SHORT_5_5_5_1  2
    RGB                UNSIGNED_SHORT_5_6_5    2
    LUMINANCE_ALPHA    UNSIGNED_BYTE           2
    LUMINANCE          UNSIGNED_BYTE           1
    ALPHA              UNSIGNED_BYTE           1
```

> 如果type类型是 UNSIGNED_BYTE， 则表示每个分量分别占据 1 个 byte; <br />
> 如果是其他类型，则表示所有分量共享一个 ushort(2个byte) 。 <br />
> OpenGL ES 最多支持 32 位颜色值。

对于像素矩形数据的传输，适当地选择内存中数据的对齐方式，能够提升数据传输的性能。 <br />
UNPACK_ALIGNMENT 用于指明内存中的数据是按多少位对其的，即每一行中所有分量的数据(按位算)是 UNPACK_ALIGNMENT 的多少整数倍。<br />
例如，对于分量数据类型 UNSIGNED_BYTE 的 RGB(A)，可以按照8位对齐。

```c++
    // Cocos2d-x 中按照纹理像素宽度的位数设置对齐方式
    bool Texture2D::initWithMipmaps(MipmapInfo* mipmaps, int mipmapsNum, PixelFormat pixelFormat, int pixelsWide, int pixelsHigh)
    {
        
    }

```























END