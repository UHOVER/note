# 纹理

> 3D 图形渲染最重要的工作之一是将纹理应用到物体表面，这个过程主要发生在片段着色器工作的阶段，使光栅化阶段插值计算得出的纹理坐标从纹理中采样，然后对片段进行着色，可以处理丰富的特效，如光照、阴影等。<br />
> 纹理是其实现的重要基础。<br/>
> 
> 纹理的存储格式影响着应用程序包的大小，也占据了应用程序的大部分内存。<br />
> Cocos2d-x 通过 Texture2D 类来创建和管理 OpenGL ES 纹理。<br />
> Texture2D 类讲述 纹理的格式、多级纹理、纹理绑定以及怎样在内存中管理纹理、各种压缩纹理格式的处理方法。

- 光栅化

在 OpenGL ES 2.0 的绘图管线中，光栅化阶段用于将投影到 2D 屏幕上的图元转换为帧缓冲中整数坐标位置上的片段，<br />
每个片段都会包含颜色、深度和模板值。

光栅化分为两个步骤:

> 1) 确定视窗上哪些整数位置的片段需要被图元覆盖。<br />
> 2) 对图元进行插值计算，得出每个片段的颜色和深度。 这些颜色和深度值被送入后续的阶段(片段操作，Per-Fragment Operations) 进行处理，最后的结果将用于更新帧缓冲上该位置的信息。

每个片段的颜色值由片段着色器决定，片段着色器会使用光栅化生成的一些易变(Varying) 变量。

> 例如，纹理坐标等用于计算颜色值，片段的深度值则由光栅化决定。

1、多重采样

> 反锯齿(Anti-aliasing) 也称抗锯齿或边缘柔化，是一种用于消除显示器输出的画面中图像边缘出现锯齿的技术。<br />
> 
> 那些锯齿通常是因为高分辨率信号以低分辨率表示或无法准确运算出3D图形坐标所导致的图形混叠而产生的。

在光栅化的过程中，由于屏幕是由离散的像素点组成的，所以在对图元进行采样时可能会丢失一部分，导致其边缘出现锯齿。<br />

默认(不开启多重采样) Cocos2d-x 中使用 DrawNode 绘制的倾斜的线段，像素之间过渡非常生硬，出现了比较明显的锯齿。<br />

在 OpenGL ES 中使用多重采样(MultiSampling)技术解决锯齿问题，与单重采样不同，帧缓冲上的每个像素不是来自单个片段中心位置的采样，而是基于附近多个位置的采样共同决定的一个颜色值。<br />
因此，相对于单重采样，帧缓冲额外的多重采样缓冲区来存储这些额外采样点的颜色、深度和模板值，这就使图元的边缘能够比较平滑地过渡，从而减小这种视觉的瑕疵。<br />

Cocos2d-x默认不开启多重采样，需要通过手动修改 CCEAGLView 的初始化方法的 multiSampling 参数来开启。

```c++
    /**
        multiSampling 参数的值设为 YES，则Cocos2d-x开始多重采样在DrawNode 中使用
        numberOfSamples 为每个片段包含的邻近采样点的数量，数量越多，抗锯齿的效果越明显，
        相应地也影响性能。
        这个最大数量受硬件支持的限制，可以通过 getIntegerv(GL_MAX_SAMPLES)来查询当前硬件支持的最大数量
    */
    - (BOOL) application:(UIApplication*)application didFinishLaunchingWithOptions: (NSDictionary*)launchOptions
    {
        CCEAGLView* eaglView = [CCEAGLView viewWithFrame: [window bounds]
        pixelFormat: kEAGLColorFormatRGBA8
        depthFormat: GL_DEPTH24_STENCIL8_OES
        preserveBackbuffer: NO
        sharegroup: nil
        multiSampling: NO
        numberOfSamples: 0];
    }
```

在一般2D游戏中，由于大部分精灵都是规则且垂直于摄像机的矩形区域，所以锯齿现象不是很明显。<br />
但是，如果游戏中需要绘制一些不规则的线段或多边形，则最好开启多重采样。<br />

> 注意: <br />
> 开启多重采样后，缓冲区的像素信息不再被存储到帧缓冲中，而是被存储到一个特殊的多重采样的缓冲区中。<br />
> 多重采样只能在初始化 OpenGL ES 时设置，之后不能被修改，<br />
> 这是因为多重采样与单个像素点采样在实现机制上有很大的区别。<br />
> OpenGL ES 中的多重采样只是针对多边形的边缘进行抗锯齿处理，对应用程序性能的影响相对比较小。

2、纹理坐标

OpenGL ES 纹理坐标以纹理的左下角为坐标原点，有两种度量形式:

> 1) 顶点在纹理中的纹理坐标通常用(u,v) 表示，分别是纹理的宽度和高度，由客户端应用程序提供
> 2) 在片段着色器中使用片段纹理坐标通常用(s,t)表示，取值范围(0.0,0.0)~(1.0,1.0)

- 像素矩形

像素矩形(Pixel Pectangles) 表示一个矩形区域的二维像素数组。<br />
它可以用来表示一个矩形区域的颜色、深度或者模板值，对应其数组的每个像素值分别表示颜色、深度和模板。

> 存储颜色值的像素矩形可以通过 TexImage2D 及相关命令定义，并将数据由客户端内存中传输至 GL 服务端内存中，或通过 ReadPixels 及相关命令将数据从帧缓冲区中读取到客户端内存中。<br />
> 
> 将客户端的颜色数据传输至GL服务端的过程成为解包(Unpack) <br />
> 将服务端像素矩形中的像素数据读取到客户端的过程称为打包(Pack)

通过TexImage2D及相关命令定义的像素矩形称为纹理。<br />
纹理由纹理像素(Texels)组成，简称纹素。<br />

> 一个2D纹理由一个二维的纹理数组组成，纹理的宽度表示数组的列数，高度表示数组的行数，<br />
> 数组中的第一个元素表示纹理左下角的像素点。<br />
> 3D 纹理在 2D 纹理上增加一个深度(Depth)，它由一个三维的纹理像素数组组成。

1、像素存储模式:

> 在纹理的传输过程中，所有用于控制客户端中的纹素编码的参数都使用 PixeStorei 命令 "void PixelStorei(enum pname, T param);" 设置。 <br />
> PixeStorei 命令会影响 TexImage2D、ReadPixels 及其他像素矩形数据传输相关的命令。<br />

```c++  
    参数名称        类型      初始值     合法值
UNPACK_ALIGNMENT  integer    4       1,2,4,8
```

2、纹理数据的传输

客户端内存中的像素数据传输到 GL 内存中的过程称为解包(Unpacking) <br />
其中输入是客户端内存中以某种方式编码的像素数据，输出是取值 [0, 1] 的浮点型 RGBA 像素值。<br />
按照这个传输过程的顺序解释纹理数据的传输。<br />

任何传输或者返回像素矩形的命令都需要包含一些基本参数(特定的传输过程还需要额外的参数，如 glTexImage2D) <br />
如 format、width、height、data、type

> format: <br />
> format 用来表示一个像素矩形中数据的构成。<br />
> 在内存中，data 是一个 ubyte 或 ushort 数组，数组中的元素被按 1、2、3或4个分量(Component)形成一个组(Group) 的集合。<br />
> 因此，format 就描述了每个组的构成，包括每个分量的构成及顺序。<br />
> 按照类型，一个像素矩形可能表示的是颜色值、深度值、模板值，以及深度与模板共同构成的数据值。<br />
> 一个颜色值最多由4个分量构成，深度值和模板值由一个分量构成，深度与模板共同构成的数据值则由2个分量构成。

```c++
    // 像素矩形传输的格式名称及意义
    格式名称(format)    分量意义及顺序     目标缓冲区
    ALPHA              A                Color
    RGB                R,G,B            Color
    RGBA               R,G,B,A          Color
    LUMINANCE          Luminance        Color
    LUMINANCE_ALPHA    Luminance,A      Color

    //
    data: 是 ubyte 或 ushort 数组
    数组的元素是一个组的集合
    组有 1~4个分量
    format 描述 组的构成、分量的构成及顺序
    一个颜色值最多由4 个分量构成
    深度值和模板值是 1个分量
    深度与模板共同构成的数据值 是 2 个分量构成
```

> data: <br />
> 表示客户端内存中像素矩形数组的指针，也可能是指向一个缓冲对象的偏移值。 <br />

> type 参数的可选类型

```c++
    // 分量的位数及GL数据类型
    // type 每个像素分量的构成(左) 以及data数组中每个元素的数据类型(右)，它只能为ubyte或ushort 数据类型
    类型(type)枚举          GL数据类型
    UNSIGNED_BYTE          ubyte
    UNSIGNED_SHORT_5_6_5   ushort
    UNSIGNED_SHORT_4_4_4_4 ushort
    UNSIGNED_SHORT_5_5_5_1 ushort

```

> 对于表示颜色的像素矩形，每个分量(R、G、B和A)在数组中所占的位数可能不同

3、解包

> format 描述了像素矩形的数据类型(颜色、深度或模板)。<br />
> type 定义了像素数据分量的构成，<br />
> 因此所有编码格式的像素矩形的数量由 format 和 type 共同决定。

```c++
    // OpenGL ES 支持的所有像素格式和类型的组合
    格式名称(format)    类型(type)枚举          bytes/pixel
    RGBA               UNSIGNED_BYTE           4
    RGB                UNSIGNED_BYTE           3
    RGBA               UNSIGNED_SHORT_4_4_4_4  2
    RGBA               UNSIGNED_SHORT_5_5_5_1  2
    RGB                UNSIGNED_SHORT_5_6_5    2
    LUMINANCE_ALPHA    UNSIGNED_BYTE           2
    LUMINANCE          UNSIGNED_BYTE           1
    ALPHA              UNSIGNED_BYTE           1
```

> 如果type类型是 UNSIGNED_BYTE， 则表示每个分量分别占据 1 个 byte; <br />
> 如果是其他类型，则表示所有分量共享一个 ushort(2个byte) 。 <br />
> OpenGL ES 最多支持 32 位颜色值。

对于像素矩形数据的传输，适当地选择内存中数据的对齐方式，能够提升数据传输的性能。 <br />
UNPACK_ALIGNMENT 用于指明内存中的数据是按多少位对其的，即每一行中所有分量的数据(按位算)是 UNPACK_ALIGNMENT 的多少整数倍。<br />
例如，对于分量数据类型 UNSIGNED_BYTE 的 RGB(A)，可以按照8位对齐。

```c++
    // Cocos2d-x 中按照纹理像素宽度的位数设置对齐方式
    bool Texture2D::initWithMipmaps(MipmapInfo* mipmaps, int mipmapsNum, PixelFormat pixelFormat, int pixelsWide, int pixelsHigh)
    {
        // Set the row align only when mipmapsNum == 1 and the data is uncompressed
        if (mipmapsNum == 1 && !info.compressed)
        {
            unsigned int bytesPerRow = pixelsWide * info.bpp / 8;
            if(bytesPerRow % 8 == 0){
                glPixelStorei(GL_UNPACK_ALIGNMENT, 8);
            }
            else if(bytesPerRow % 4 == 0) {
                glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
            }
            else if (bytesPerRow % 2 == 0) {
                glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
            }
            else{
                glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
            }
        }
        else{
            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        }
    }

```

> 对于 type 为 UNSIGNED_SHORT_5_6_5、UNSIGNED_SHORT_4_4_4_4或UNSIGNED_SHORT_5_5_5_1的类型，它们所有的分量构成的组被包装为一个短整型(ushort)，它们的分量的组成及每个分量的占据的位数是根据type计算出来的，type必须与format 保持匹配

··· <br />
// TODO <br />
··· <br />


- 客户端图像格式

> 上面讨论的关于纹理的格式及数据类型，都是指纹理在 GL 服务端的存储模式。<br />
> 在纹理传输到 GL 服务端以供片段着色器等使用时，我们必须指明纹理在 GL 服务端以怎样的方式存储，这需要通过 TexImage2D 等命令来设置。<br />
> 为了保证实时的渲染性能，服务端的纹理数据通常是未压缩的(压缩纹理除外)，<br />
> 因为这样能够保证最快的读取速度。<br />
> 而客户端的图像资源通常压缩为 PNG 或 JPG 格式，这将占用更少的磁盘空间。

因此，客户端在传输纹理时首先需要解压图像资源，将其转换为 GL 服务端支持的纹理格式，才能保证纹理的正确的使用。<br />
这涉及两方面的内容: <br />
客户端图像格式与服务端纹理格式的一一对应，以及客户端图像数据在各种格式之间的转换。

1、纹理格式的对应关系

PixelFormat 枚举定义了 Cocos2d-x 支持的图像格式，程序中添加的所有图像资源，最后都要转换为这些格式被使用。

```c++
    /**
        PixelFormat 枚举的定义，这里省去了压缩纹理格式
    */
    class CC_DLL Texture2D : public Ref
    {
    public:
        enum class PixelFormat 
        {
            // ! auto detect the type
            AUTO,
            //! 32-bit texture : BGRA8888
            BGRA8888,
            // ! 32-bit texture : RGBA8888
            RGBA8888,
            // ! 24-bit texture : RGB888
            RGB888,
            // ! 16-bit texture without Alpha channel
            RGB565,
            // ! 8-bit texture used as masks
            A8,
            // ! 8-bit intensity texture
            I8,
            // ! 16-bit textures used as masks
            AI88,
            // ! 16-bit textures : RGBA4444
            RGBA4444,
            // ! 16-bit textures : RGB5A1
            RGB5A1,
        };
    };
```

每个客户端的格式名称对应GL服务端格式的一种，只有相匹配的图像格式才能被正确传输到GL服务端。<br />
在 Cocos2d-x中，自定义类型 PixelFormatInfoMap 定义了它们与 OpenGL ES 纹理格式的转换关系。

| 客户端格式名称   | GL格式(format)/客户端格式(format)| GL 数据类型(type) |
| ------------- |:-----------------------------:| -----------------:|
| BGRA8888      | GL_RGBA/GL_BGRA               | GL_UNSIGNED_BYTE  |
| RGBA8888      | GL_RGBA                       | GL_UNSIGNED_BYTE  |
| RGBA4444      | GL_RGBA                       | GL_UNSIGNED_SHORT_4_4_4_4 |
| RGB5A1        | GL_RGBA                       | GL_UNSIGNED_SHORT_5_5_5_1 |
...

2、图像数据格式转换

因为应用程序中的图像资源通常使用 PNG、JPG 之类的压缩格式，所以，客户端需要在不同的格式之间对图像数据进行转换。

> 例如，使用 JPG 格式时，Texture2D 需要将 JPG 格式的图像数据转换为 RGBA8888 格式的数据。<br />
> 处于对游戏性能的考虑，应用程序也可能将高分辨率的 RGBA8888 格式的图像转换为低分辨率的 RGBA4444 格式的图像数据。

Texture2D 提供了一个 convertDataToFormat() 方法来实现不同数据格式之间的转换。<br />
如果目标格式为 AUTO 类型，则该方法会尝试将其转换为一种最接近的格式。<br />
Texture2D Default is: RGBA8888 (32-bit textures)

```c++
    class CC_DLL Texture2D : public Ref
    {
    public:
        static PixelFormat convertDataToFormat(const unsigned char* data, ssize_t dataLen, PixelFormat originFormat, PixelFormat format, unsigned char** outData, ssize_t* outDataLen);
    };

    /**
        Texture2D 通过 Image 实例初始化时完成这个数据转换过程
        g_defaultAlphaPixelFormat: 设置的格式，默认 RGBA8888
    */
    bool Texture2D::initWithImage(Image *image)
    {
        return initWithImage(image, g_defaultAlphaPixelFormat);
    }

    bool Texture2D::initWithImage(Image* image, PixelFormat format)
    {
        unsigned char* tempData = image->getData();
        if (image->getNumberOfMipmaps() > 1){
            //
        }else if (image-<isCompressed()){
            //
        }else{
            // compute pixel format
            if (format != PixelFomat::NONE){
                pixelFormat = format;
            }else{
                pixelFormat = g_defaultAlphaPixelFormat;
            }

            unsigned char* outTempData = nullptr;
            ssize_t outTempDataLen = 0;

            pixelFormat = convertDataToFormat(tempData, tempDataLen, renderFormat, pixelFormat, &outTempData, &outTempDataLen);

            initWithData(outTempData, outTempDataLen, pixelFormat, imageWidth, imageHeight, imageSize);

            if (outTempData != nullptr  && outTempData != tempData)
            {
                delete [] outTempData;
            }

            return ture;
        }
    }

    /**
        format被设置为 PixelFormat::NONE。
        这样，initWithImage 就会使用 g_defaultAlphaPixelFormat 的值,
        g_defaultAlphaPixelFormat 的默认值为 AUTO
    */
    static Texture2D::PixelFormat g_defaultAlphaPixelFormat = Texture2D::PixelFormat::DEFAULT;

    /**
        实际上，当应用程序初始化时，其默认值为 RGBA8888,
        即所有的资源将被转换为 RGBA8888 格式，
        在 GL 中，每个像素占据32位内存，如 setDefaultValues()
    */
    void Director::setDefaultValues(void)
    {
        Configuration *conf = Configuration::getInstance();

        // Default pixel format for PNG images with alpha
        std::string pixel_format = conf->getValue("cocos2d.x.texture.pixel_format_for_png", Value("rgba8888").asString());

        if (pixel_format == "rgba8888") 
            Texture2D::setDefaultAlphaPixelFormat(Texture2D::PixelFormat::RGBA8888);
        else if (pixel_format == "rgba4444")
            Texture2D::setDefaultAlphaPixelFormat(Texture2D::PixelFormat::RGBA4444);
        else if (pixel_format == "rgba5551")
            Texture2D::setDefaultAlphaPixelFormat(Texutre2D::PixelFormat::RGBA5A1);
    }

    /**
        在实际开发中，可以将其指定为 AUTO。
        这样 JPG 将被转换为 RGB888,而不是 RGBA8888，减少了1/4 的内存浪费 ？？？？
    */
```

- 纹理对象和加载纹理

在绘图管线中，纹理主要在片段着色器中被使用。<br />
每一次绘制命令(glDrawArray 或 glDrawElements) 执行时，需要告诉 OpenGL ES 当前管线中使用的一个或多个纹理(Multitexturing)，这涉及创建纹理对象、绑定当前纹理对象、将纹理数据加载到OpenGL ES 内存中等命令操作。

> 一个纹理对象是一个容器，它持有该纹理被使用时需要用到的所有数据，这些数据包括图像像素数据、过滤(Filtering Mode) 模式、扩展模式(Wrap Mode)等。<br />

```c++
    /**
        在 OpenGL ES 中，用一个无符号的整数表示该纹理对象的名称，纹理对象使用 glGenTextures 命令创建。
        n 表示需要创建的纹理对象的数量，textures 用于保存分配的纹理名称。
    */
    void glGenTextures(GLsizei n, GLunit *textures)

    /**
        当我们不再使用一个纹理时，可以使用 glDeleteTextures 命令删除内存中的纹理对象
    */
    void glDeleteTextures(GLsizei n, GLuint *textures)
```

创建一个纹理对象之后，为了操作该纹理对象，必须绑定纹理对象。<br />
由于应用程序并不直接持有纹理对象指针，所以，OpenGL ES 通过设定当前纹理对象对其进行操作。<br />
设定当前纹理对象后，后续(直到纹理对象被删除或下一个纹理绑定命令被执行之前)的操作(如 glTexImage2D 和 glTexParameter) 将作用在该纹理对象上。

```c++
    // 应用程序使用 glBindTexture 命令绑定当前纹理
    void glBindTexture(GLenum target, GLuint texture)
```

绑定当前纹理对象后，就可以将纹理数据加载到 OpenGL ES 内存中。<br />
在OpenGL ES 中，主要使用 glTexImage2D 命令加载纹理。<br />
一旦该命令被执行，会立即将图像像素数据从客户端传输至服务端的内存中，后续对客户端数据的修改不会影响OpenGL ES 中绑定的纹理数据。<br />
因此，客户端在将数据加载到 OpenGL ES 内存中后，应该立即删除客户端的图像数据缓冲对象(它将不再被使用)

```c++
    /**
        target 表示 GL_TEXTURE_2D 或立方体纹理的一个面。
        level 表示多级纹理的级别
        internalFormat 表示纹理在 GL 中的存储格式
        width 和 height 表示纹理的尺寸
        pixels 表示客户端的图像数据缓冲对象
    */
    void glTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels)

    // 应用程序可以通过 glTexParameteri 来设置各种模式
    void glTexParameteri(GLenum target, GLenum pname, GLint param)
```

通过以上命令，可以创建、加载纹理，或修改纹理的绘制模式。<br />

Cocos2d-x 在创建一个 Texture2D 对象时会执行以上命令，每个 Texture2D 对象对应于一个纹理对象。<br />

```c++
    // Texture2D 类向应用程序提供一个简单的创建或管理纹理对象的方式
    bool Texture2D::initWithMipmaps(MipmapInfo* mipmaps, int mipmapsNum, PixelFormat pixelFormat, int pixelsWide, int pixelsHigh)
    {
        glGenTextures(1, &_name);
        GL::bindTexture2D(_name);

        if(mipmapsNum == 1)
        {
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        }else{
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);
        }

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        CHECK_GL_ERROR_DEBUG(); // clean possible GL error

        // Specify OpenGL texture image
        int width = pixelsWide;
        int height = pixelsHeigh;

        for (int i = 0; i < mipmapsNum; ++i)
        {
            unsigned char *data = mipmaps[i].address;
            GLsizei datalen = mipmaps[i].len;

            if(info.compressed)
            {
                glCompressedTexImage2D(GL_TEXTURE_2D,i,info.internalFormat, (GLsizei)width, (GLsizei)height, 0, datalen, data);
            }else{
                glTexImage2D(GL_TEXTURE_2D,i,info.internalFormat, (GLsizei)width, (GLsizei)height, 0, info.format, info.type, data);
            }

            width = MAX(width >> 1, 1);
            height = MAX(height >> 1, 1)
        }
        return true;
    }
```

纹理一旦被传输至GL服务端，就会一直驻留在GPU管理的内存中，<br />
因此，应该留意那些不再被使用的纹理，及时地从 GL 内存中删除它们，以减少应用程序内存的占用。

- 纹理单元与多重纹理

OpenGL ES 支持在一个绘图管线中使用多个纹理，这通常被用在3D法线贴图等场景中，用来增强画面表现力。<br />
可以在片段着色器中使用特定的算法

```c++
    /**
        OpenGL ES 使用纹理单元来管理多个纹理的使用，
        每个纹理对象都被放到一个纹理单元中，
        使用 glActiveTexture 命令来激活纹理单元

        参数 texture 是一个索引，默认第一个纹理使用 GL_TEXTURE0 枚举值，其值为0，
        该纹理对象将作为
    */
    void glActiveTexture(GLenum texture)
```
































END