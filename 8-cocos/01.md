#### Cocos2d-x 3.0 的新特性

##### 命名
- 3.0版本之前一直保持与Cocos2d-iPhone一致的Objective-C 接口风格，例如类名的"CC"前缀、sharedXXX()的单例命名和属性使用等。

> CCSprite被更名为Sprite等。
> 一些全局方法也被加入相应的命名空间中，如与绘制几何基元相关的方法被加入 DrawPrimitves 命名空间，与 OpenGL ES 相关的命名空间。

```c++
    v2.x                 v3.x
    CCSprite            cocos2d::Sprite
    ccDrawPoint()       DrawPrimitives::drawPoint()
    ccGLBlendFunc()     GL::blendFunc()
```

> 用 getInstance() 和 destroyInstance() 方法代替 sharedXXX() 和 endXXX() 方法来使用单例。

```c++
    v2.x                        v3.x
CCDirector::sharedDirector()    Director::getInstance()
CCDirector::endDirector()       Director::destroyInstance()
```

> 在 v3.x中，TextureCache、Dispatcher 等对象不再是全局的单例，它们属于 Director,通过Director来获取其实例。
> 使 v3.x 可以支持多个窗口，即多个 Director, 如 auto tc = Director::getInstance()->getTextureCache()
> 使用 get 前缀来表示属性获取方法

```c++
    v2.x                                v3.x
node->boundingBox()                 node->getBoundingBox()
sprite->nodeToParentTransform()     sprite->getNodeToParentTransform()
```

> 属性获得方法使用 const 声明来限制其对自身属性的修改

```c++
// v2.x
virtual float getScale();

// v3.x
virtual float getScale() const;
```

> 对于POD类型，使用引用参数来代替指针传递(包括 TexParams、Point、Size等)，这些对象被分配到栈中，更易于内存的管理。

```c++
// v2.x
void setTexParamenters(ccTexParams* texParams);

// v3.x
void setTexParameters(const ccTexParams& texParams);
```

- 使用 clone() 代替 copy() 方法: clone() 方法用来深度复制一个对象

> 与 copy() 方法不同的是，对于Cocos2d-x系统提供的可复制的对象，clone() 方法直接返回一个加入自动回收池的对象，调用者不再需要手动将其加入自动回收池，减少类型转换的时间。

```c++
    // v2.1
    CCMoveBy *action = (CCMoveBy*) move->copy();
    action->autorelease();

    // V3.O
    auto action = move->clone(); // 直接返回 autorelease 对象，不需要类型转换
```

- v3.x使用了部分 C++11的特性，主要包括 std::function、强类型枚举、std::thread、override和final关键字、移动语义等

> std::function 可以被传递一个 lambda 表达式，亦可以通过 std::bind 绑定一个方法指针，提升可读性和灵活性。同时lambda表达式还可以使用当前作用域中的变量。

```c++
// 创建一个CallFunc对象
CallFunc::create([&](){
        auto sprite = Sprite::create("sp.png");
        this->addChild(sprite);
    });
```

- v2.x 用k前缀来表示枚举和常量。由于这些参数可以被int型变量替换，会造成难以察觉的错误，v3.x使用强类型枚举来避免这种情况

```c++
    v2.x                                v3.x
 kCCTexture2DPixelFormat_RGBA8888   Texture2D::PixelFormat::RGBA8888
 kCCDirectorProjectopnCustom        Director::Projection::CUSTOM
 

```


##### 渲染
- 在一般的3D应用程序中，OpenGL 渲染管线可以根据片段的深度来正确处理场景中的元素层级，只需要处理透明与非透明的绘制顺序即可。2D应用程序中，每个元素通常具有相同的深度，Cocos2d-x给每个元素指定一个逻辑深度，并按照这个深度对UI元素进行排序，游戏中的每一帧只需要对UI树做一个 深度优先遍历，就可以按照正确的顺序绘制整个场景，除了渲染，在每一帧上几乎没有额外的计算工作，因此能够比较高效地执行渲染工作

> 这套架构设计不易于扩展，过时。
> 例如: 开发者无法修改一个元素在全局的层级，每个元素都按照UI树的结构绘制，不能在父级或子级之间变更层级。由于每个元素(如Sprite)负责自己的绘制，所以不易针对绘制做更好的优化。
> 例如：相邻的两个元素使用了相同的纹理和相同的 OpenGL ES 绘制参数，但是仍然需要单独绘制两次。

- Cocos2d-x 3.0 重新设计了渲染机制，将渲染从UI树遍历中分离出来，这不仅使其架构更灵活、更易于拓展，还可以针对渲染进行优化(如自动批绘制技术)。新的渲染架构设计提升了引擎的性能与灵活性。


















































END